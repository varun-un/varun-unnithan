{"id":"node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js","dependencies":[{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\Shaders\\gpuUpdateParticles.vertex.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\package.json","includedInParent":true,"mtime":1618440501386},{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\.babelrc","includedInParent":true,"mtime":1618361427593},{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\package.json","includedInParent":true,"mtime":499162500000},{"name":"../Materials/effect","loc":{"line":1,"column":23},"parent":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\Shaders\\gpuUpdateParticles.vertex.js","resolved":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\Materials\\effect.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gpuUpdateParticlesVertexShader = void 0;\n\nvar _effect = require(\"../Materials/effect\");\n\nvar name = 'gpuUpdateParticlesVertexShader';\nvar shader = \"#version 300 es\\n#define PI 3.14159\\nuniform float currentCount;\\nuniform float timeDelta;\\nuniform float stopFactor;\\n#ifndef LOCAL\\nuniform mat4 emitterWM;\\n#endif\\nuniform vec2 lifeTime;\\nuniform vec2 emitPower;\\nuniform vec2 sizeRange;\\nuniform vec4 scaleRange;\\n#ifndef COLORGRADIENTS\\nuniform vec4 color1;\\nuniform vec4 color2;\\n#endif\\nuniform vec3 gravity;\\nuniform sampler2D randomSampler;\\nuniform sampler2D randomSampler2;\\nuniform vec4 angleRange;\\n#ifdef BOXEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\nuniform vec3 minEmitBox;\\nuniform vec3 maxEmitBox;\\n#endif\\n#ifdef POINTEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#endif\\n#ifdef HEMISPHERICEMITTER\\nuniform float radius;\\nuniform float radiusRange;\\nuniform float directionRandomizer;\\n#endif\\n#ifdef SPHEREEMITTER\\nuniform float radius;\\nuniform float radiusRange;\\n#ifdef DIRECTEDSPHEREEMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#else\\nuniform float directionRandomizer;\\n#endif\\n#endif\\n#ifdef CYLINDEREMITTER\\nuniform float radius;\\nuniform float height;\\nuniform float radiusRange;\\n#ifdef DIRECTEDCYLINDEREMITTER\\nuniform vec3 direction1;\\nuniform vec3 direction2;\\n#else\\nuniform float directionRandomizer;\\n#endif\\n#endif\\n#ifdef CONEEMITTER\\nuniform vec2 radius;\\nuniform float coneAngle;\\nuniform vec2 height;\\nuniform float directionRandomizer;\\n#endif\\n\\nin vec3 position;\\n#ifdef CUSTOMEMITTER\\nin vec3 initialPosition;\\n#endif\\nin float age;\\nin float life;\\nin vec4 seed;\\nin vec3 size;\\n#ifndef COLORGRADIENTS\\nin vec4 color;\\n#endif\\nin vec3 direction;\\n#ifndef BILLBOARD\\nin vec3 initialDirection;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nin float angle;\\n#else\\nin vec2 angle;\\n#endif\\n#ifdef ANIMATESHEET\\nin float cellIndex;\\n#ifdef ANIMATESHEETRANDOMSTART\\nin float cellStartOffset;\\n#endif\\n#endif\\n#ifdef NOISE\\nin vec3 noiseCoordinates1;\\nin vec3 noiseCoordinates2;\\n#endif\\n\\nout vec3 outPosition;\\n#ifdef CUSTOMEMITTER\\nout vec3 outInitialPosition;\\n#endif\\nout float outAge;\\nout float outLife;\\nout vec4 outSeed;\\nout vec3 outSize;\\n#ifndef COLORGRADIENTS\\nout vec4 outColor;\\n#endif\\nout vec3 outDirection;\\n#ifndef BILLBOARD\\nout vec3 outInitialDirection;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nout float outAngle;\\n#else\\nout vec2 outAngle;\\n#endif\\n#ifdef ANIMATESHEET\\nout float outCellIndex;\\n#ifdef ANIMATESHEETRANDOMSTART\\nout float outCellStartOffset;\\n#endif\\n#endif\\n#ifdef NOISE\\nout vec3 outNoiseCoordinates1;\\nout vec3 outNoiseCoordinates2;\\n#endif\\n#ifdef SIZEGRADIENTS\\nuniform sampler2D sizeGradientSampler;\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nuniform sampler2D angularSpeedGradientSampler;\\n#endif\\n#ifdef VELOCITYGRADIENTS\\nuniform sampler2D velocityGradientSampler;\\n#endif\\n#ifdef LIMITVELOCITYGRADIENTS\\nuniform sampler2D limitVelocityGradientSampler;\\nuniform float limitVelocityDamping;\\n#endif\\n#ifdef DRAGGRADIENTS\\nuniform sampler2D dragGradientSampler;\\n#endif\\n#ifdef NOISE\\nuniform vec3 noiseStrength;\\nuniform sampler2D noiseSampler;\\n#endif\\n#ifdef ANIMATESHEET\\nuniform vec3 cellInfos;\\n#endif\\nvec3 getRandomVec3(float offset) {\\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\\n}\\nvec4 getRandomVec4(float offset) {\\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\\n}\\nvoid main() {\\nfloat newAge=age+timeDelta;\\n\\nif (newAge>=life && stopFactor != 0.) {\\nvec3 newPosition;\\nvec3 newDirection;\\n\\nvec4 randoms=getRandomVec4(seed.x);\\n\\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\\noutAge=newAge-life;\\n\\noutSeed=seed;\\n\\n#ifdef SIZEGRADIENTS\\noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\\n#else\\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\\n#endif\\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a;\\n#ifndef COLORGRADIENTS\\n\\noutColor=color1+(color2-color1)*randoms.b;\\n#endif\\n\\n#ifndef ANGULARSPEEDGRADIENTS\\noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\\n#else\\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\\n#endif\\n\\n#ifdef POINTEMITTER\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nnewPosition=vec3(0,0,0);\\nnewDirection=direction1+(direction2-direction1)*randoms3;\\n#elif defined(BOXEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\nnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\\nnewDirection=direction1+(direction2-direction1)*randoms3;\\n#elif defined(HEMISPHERICEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\n\\nfloat phi=2.0*PI*randoms2.x;\\nfloat theta=acos(2.0*randoms2.y-1.0);\\nfloat randX=cos(phi)*sin(theta);\\nfloat randY=cos(theta);\\nfloat randZ=sin(phi)*sin(theta);\\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\\nnewDirection=newPosition+directionRandomizer*randoms3;\\n#elif defined(SPHEREEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\n\\nfloat phi=2.0*PI*randoms2.x;\\nfloat theta=acos(2.0*randoms2.y-1.0);\\nfloat randX=cos(phi)*sin(theta);\\nfloat randY=cos(theta);\\nfloat randZ=sin(phi)*sin(theta);\\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\\n#ifdef DIRECTEDSPHEREEMITTER\\nnewDirection=direction1+(direction2-direction1)*randoms3;\\n#else\\n\\nnewDirection=newPosition+directionRandomizer*randoms3;\\n#endif\\n#elif defined(CYLINDEREMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nvec3 randoms3=getRandomVec3(seed.z);\\n\\nfloat yPos=(randoms2.x-0.5)*height;\\nfloat angle=randoms2.y*PI*2.;\\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\\nfloat xPos=positionRadius*cos(angle);\\nfloat zPos=positionRadius*sin(angle);\\nnewPosition=vec3(xPos,yPos,zPos);\\n#ifdef DIRECTEDCYLINDEREMITTER\\nnewDirection=direction1+(direction2-direction1)*randoms3;\\n#else\\n\\nangle=angle+((randoms3.x-0.5)*PI);\\nnewDirection=vec3(cos(angle),randoms3.y-0.5,sin(angle));\\nnewDirection=normalize(newDirection);\\n#endif\\n#elif defined(CONEEMITTER)\\nvec3 randoms2=getRandomVec3(seed.y);\\nfloat s=2.0*PI*randoms2.x;\\n#ifdef CONEEMITTERSPAWNPOINT\\nfloat h=0.0001;\\n#else\\nfloat h=randoms2.y*height.y;\\n\\nh=1.-h*h;\\n#endif\\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\\nlRadius=lRadius*h;\\nfloat randX=lRadius*sin(s);\\nfloat randZ=lRadius*cos(s);\\nfloat randY=h*height.x;\\nnewPosition=vec3(randX,randY,randZ);\\n\\nif (abs(cos(coneAngle)) == 1.0) {\\nnewDirection=vec3(0.,1.0,0.);\\n} else {\\nvec3 randoms3=getRandomVec3(seed.z);\\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\\n}\\n#elif defined(CUSTOMEMITTER)\\nnewPosition=initialPosition;\\noutInitialPosition=initialPosition;\\n#else\\n\\nnewPosition=vec3(0.,0.,0.);\\n\\nnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\\n#endif\\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\\n#ifdef LOCAL\\noutPosition=newPosition;\\n#else\\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\\n#endif\\n#ifdef CUSTOMEMITTER\\noutDirection=direction;\\n#ifndef BILLBOARD\\noutInitialDirection=direction;\\n#endif\\n#else\\n#ifdef LOCAL\\nvec3 initial=newDirection;\\n#else\\nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\\n#endif\\noutDirection=initial*power;\\n#ifndef BILLBOARD\\noutInitialDirection=initial;\\n#endif\\n#endif\\n#ifdef ANIMATESHEET\\noutCellIndex=cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\noutCellStartOffset=randoms.a*outLife;\\n#endif\\n#endif\\n#ifdef NOISE\\noutNoiseCoordinates1=noiseCoordinates1;\\noutNoiseCoordinates2=noiseCoordinates2;\\n#endif\\n} else {\\nfloat directionScale=timeDelta;\\noutAge=newAge;\\nfloat ageGradient=newAge/life;\\n#ifdef VELOCITYGRADIENTS\\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\\n#endif\\n#ifdef DRAGGRADIENTS\\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\\n#endif\\n#if defined(CUSTOMEMITTER)\\noutPosition=position+(direction-position)*ageGradient;\\noutInitialPosition=initialPosition;\\n#else\\noutPosition=position+direction*directionScale;\\n#endif\\noutLife=life;\\noutSeed=seed;\\n#ifndef COLORGRADIENTS\\noutColor=color;\\n#endif\\n#ifdef SIZEGRADIENTS\\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\\noutSize.yz=size.yz;\\n#else\\noutSize=size;\\n#endif\\n#ifndef BILLBOARD\\noutInitialDirection=initialDirection;\\n#endif\\n#ifdef CUSTOMEMITTER\\noutDirection=direction;\\n#else\\nvec3 updatedDirection=direction+gravity*timeDelta;\\n#ifdef LIMITVELOCITYGRADIENTS\\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\\nfloat currentVelocity=length(updatedDirection);\\nif (currentVelocity>limitVelocity) {\\nupdatedDirection=updatedDirection*limitVelocityDamping;\\n}\\n#endif\\noutDirection=updatedDirection;\\n#ifdef NOISE\\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\\noutDirection=outDirection+force*timeDelta;\\noutNoiseCoordinates1=noiseCoordinates1;\\noutNoiseCoordinates2=noiseCoordinates2;\\n#endif\\n#endif\\n#ifdef ANGULARSPEEDGRADIENTS\\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\\noutAngle=angle+angularSpeed*timeDelta;\\n#else\\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\\n#endif\\n#ifdef ANIMATESHEET\\nfloat offsetAge=outAge;\\nfloat dist=cellInfos.y-cellInfos.x;\\n#ifdef ANIMATESHEETRANDOMSTART\\noutCellStartOffset=cellStartOffset;\\noffsetAge+=cellStartOffset;\\n#else\\nfloat cellStartOffset=0.;\\n#endif\\nfloat ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\\noutCellIndex=float(int(cellInfos.x+ratio*dist));\\n#endif\\n}\\n}\";\n_effect.Effect.ShadersStore[name] = shader;\n/** @hidden */\n\nvar gpuUpdateParticlesVertexShader = {\n  name: name,\n  shader: shader\n};\nexports.gpuUpdateParticlesVertexShader = gpuUpdateParticlesVertexShader;"},"sourceMaps":{"js":{"mappings":[{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":10,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":3,"column":4},"generated":{"line":10,"column":4}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":3,"column":8},"generated":{"line":10,"column":8}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":3,"column":11},"generated":{"line":10,"column":11}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":10,"column":43}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":11,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":4},"generated":{"line":11,"column":4}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":10},"generated":{"line":11,"column":10}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":11,"column":13}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":11,"column":10044}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":0},"generated":{"line":12,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":7},"generated":{"line":12,"column":15}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":0},"generated":{"line":12,"column":27}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":20},"generated":{"line":12,"column":28}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":0},"generated":{"line":12,"column":32}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":28},"generated":{"line":12,"column":36}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":383,"column":0},"generated":{"line":12,"column":42}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":384,"column":0},"generated":{"line":13,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":7},"generated":{"line":15,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":11},"generated":{"line":15,"column":4}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":41},"generated":{"line":15,"column":34}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":44},"generated":{"line":15,"column":37}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":46},"generated":{"line":16,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":46},"generated":{"line":16,"column":2}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":50},"generated":{"line":16,"column":6}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":50},"generated":{"line":16,"column":8}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":44},"generated":{"line":16,"column":12}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":52},"generated":{"line":17,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":52},"generated":{"line":17,"column":2}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":58},"generated":{"line":17,"column":8}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":58},"generated":{"line":17,"column":10}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":44},"generated":{"line":18,"column":0}},{"source":"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts","name":null,"original":{"line":385,"column":7},"generated":{"line":18,"column":1}}],"sources":{"../../../sourceES6/core/Shaders/gpuUpdateParticles.vertex.ts":"import { Effect } from \"../Materials/effect\";\n\nlet name = 'gpuUpdateParticlesVertexShader';\nlet shader = `#version 300 es\n#define PI 3.14159\nuniform float currentCount;\nuniform float timeDelta;\nuniform float stopFactor;\n#ifndef LOCAL\nuniform mat4 emitterWM;\n#endif\nuniform vec2 lifeTime;\nuniform vec2 emitPower;\nuniform vec2 sizeRange;\nuniform vec4 scaleRange;\n#ifndef COLORGRADIENTS\nuniform vec4 color1;\nuniform vec4 color2;\n#endif\nuniform vec3 gravity;\nuniform sampler2D randomSampler;\nuniform sampler2D randomSampler2;\nuniform vec4 angleRange;\n#ifdef BOXEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\nuniform vec3 minEmitBox;\nuniform vec3 maxEmitBox;\n#endif\n#ifdef POINTEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#endif\n#ifdef HEMISPHERICEMITTER\nuniform float radius;\nuniform float radiusRange;\nuniform float directionRandomizer;\n#endif\n#ifdef SPHEREEMITTER\nuniform float radius;\nuniform float radiusRange;\n#ifdef DIRECTEDSPHEREEMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CYLINDEREMITTER\nuniform float radius;\nuniform float height;\nuniform float radiusRange;\n#ifdef DIRECTEDCYLINDEREMITTER\nuniform vec3 direction1;\nuniform vec3 direction2;\n#else\nuniform float directionRandomizer;\n#endif\n#endif\n#ifdef CONEEMITTER\nuniform vec2 radius;\nuniform float coneAngle;\nuniform vec2 height;\nuniform float directionRandomizer;\n#endif\n\nin vec3 position;\n#ifdef CUSTOMEMITTER\nin vec3 initialPosition;\n#endif\nin float age;\nin float life;\nin vec4 seed;\nin vec3 size;\n#ifndef COLORGRADIENTS\nin vec4 color;\n#endif\nin vec3 direction;\n#ifndef BILLBOARD\nin vec3 initialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nin float angle;\n#else\nin vec2 angle;\n#endif\n#ifdef ANIMATESHEET\nin float cellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nin float cellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nin vec3 noiseCoordinates1;\nin vec3 noiseCoordinates2;\n#endif\n\nout vec3 outPosition;\n#ifdef CUSTOMEMITTER\nout vec3 outInitialPosition;\n#endif\nout float outAge;\nout float outLife;\nout vec4 outSeed;\nout vec3 outSize;\n#ifndef COLORGRADIENTS\nout vec4 outColor;\n#endif\nout vec3 outDirection;\n#ifndef BILLBOARD\nout vec3 outInitialDirection;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nout float outAngle;\n#else\nout vec2 outAngle;\n#endif\n#ifdef ANIMATESHEET\nout float outCellIndex;\n#ifdef ANIMATESHEETRANDOMSTART\nout float outCellStartOffset;\n#endif\n#endif\n#ifdef NOISE\nout vec3 outNoiseCoordinates1;\nout vec3 outNoiseCoordinates2;\n#endif\n#ifdef SIZEGRADIENTS\nuniform sampler2D sizeGradientSampler;\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nuniform sampler2D angularSpeedGradientSampler;\n#endif\n#ifdef VELOCITYGRADIENTS\nuniform sampler2D velocityGradientSampler;\n#endif\n#ifdef LIMITVELOCITYGRADIENTS\nuniform sampler2D limitVelocityGradientSampler;\nuniform float limitVelocityDamping;\n#endif\n#ifdef DRAGGRADIENTS\nuniform sampler2D dragGradientSampler;\n#endif\n#ifdef NOISE\nuniform vec3 noiseStrength;\nuniform sampler2D noiseSampler;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 cellInfos;\n#endif\nvec3 getRandomVec3(float offset) {\nreturn texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;\n}\nvec4 getRandomVec4(float offset) {\nreturn texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));\n}\nvoid main() {\nfloat newAge=age+timeDelta;\n\nif (newAge>=life && stopFactor != 0.) {\nvec3 newPosition;\nvec3 newDirection;\n\nvec4 randoms=getRandomVec4(seed.x);\n\noutLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;\noutAge=newAge-life;\n\noutSeed=seed;\n\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(0,0)).r;\n#else\noutSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;\n#endif\noutSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;\noutSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a;\n#ifndef COLORGRADIENTS\n\noutColor=color1+(color2-color1)*randoms.b;\n#endif\n\n#ifndef ANGULARSPEEDGRADIENTS\noutAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;\noutAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#else\noutAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;\n#endif\n\n#ifdef POINTEMITTER\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nnewPosition=vec3(0,0,0);\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(BOXEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\nnewPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#elif defined(HEMISPHERICEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);\nnewDirection=newPosition+directionRandomizer*randoms3;\n#elif defined(SPHEREEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat phi=2.0*PI*randoms2.x;\nfloat theta=acos(2.0*randoms2.y-1.0);\nfloat randX=cos(phi)*sin(theta);\nfloat randY=cos(theta);\nfloat randZ=sin(phi)*sin(theta);\nnewPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);\n#ifdef DIRECTEDSPHEREEMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#else\n\nnewDirection=newPosition+directionRandomizer*randoms3;\n#endif\n#elif defined(CYLINDEREMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nvec3 randoms3=getRandomVec3(seed.z);\n\nfloat yPos=(randoms2.x-0.5)*height;\nfloat angle=randoms2.y*PI*2.;\nfloat inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));\nfloat positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));\nfloat xPos=positionRadius*cos(angle);\nfloat zPos=positionRadius*sin(angle);\nnewPosition=vec3(xPos,yPos,zPos);\n#ifdef DIRECTEDCYLINDEREMITTER\nnewDirection=direction1+(direction2-direction1)*randoms3;\n#else\n\nangle=angle+((randoms3.x-0.5)*PI);\nnewDirection=vec3(cos(angle),randoms3.y-0.5,sin(angle));\nnewDirection=normalize(newDirection);\n#endif\n#elif defined(CONEEMITTER)\nvec3 randoms2=getRandomVec3(seed.y);\nfloat s=2.0*PI*randoms2.x;\n#ifdef CONEEMITTERSPAWNPOINT\nfloat h=0.0001;\n#else\nfloat h=randoms2.y*height.y;\n\nh=1.-h*h;\n#endif\nfloat lRadius=radius.x-radius.x*randoms2.z*radius.y;\nlRadius=lRadius*h;\nfloat randX=lRadius*sin(s);\nfloat randZ=lRadius*cos(s);\nfloat randY=h*height.x;\nnewPosition=vec3(randX,randY,randZ);\n\nif (abs(cos(coneAngle)) == 1.0) {\nnewDirection=vec3(0.,1.0,0.);\n} else {\nvec3 randoms3=getRandomVec3(seed.z);\nnewDirection=normalize(newPosition+directionRandomizer*randoms3);\n}\n#elif defined(CUSTOMEMITTER)\nnewPosition=initialPosition;\noutInitialPosition=initialPosition;\n#else\n\nnewPosition=vec3(0.,0.,0.);\n\nnewDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));\n#endif\nfloat power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;\n#ifdef LOCAL\noutPosition=newPosition;\n#else\noutPosition=(emitterWM*vec4(newPosition,1.)).xyz;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#ifndef BILLBOARD\noutInitialDirection=direction;\n#endif\n#else\n#ifdef LOCAL\nvec3 initial=newDirection;\n#else\nvec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;\n#endif\noutDirection=initial*power;\n#ifndef BILLBOARD\noutInitialDirection=initial;\n#endif\n#endif\n#ifdef ANIMATESHEET\noutCellIndex=cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=randoms.a*outLife;\n#endif\n#endif\n#ifdef NOISE\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n} else {\nfloat directionScale=timeDelta;\noutAge=newAge;\nfloat ageGradient=newAge/life;\n#ifdef VELOCITYGRADIENTS\ndirectionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#ifdef DRAGGRADIENTS\ndirectionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;\n#endif\n#if defined(CUSTOMEMITTER)\noutPosition=position+(direction-position)*ageGradient;\noutInitialPosition=initialPosition;\n#else\noutPosition=position+direction*directionScale;\n#endif\noutLife=life;\noutSeed=seed;\n#ifndef COLORGRADIENTS\noutColor=color;\n#endif\n#ifdef SIZEGRADIENTS\noutSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;\noutSize.yz=size.yz;\n#else\noutSize=size;\n#endif\n#ifndef BILLBOARD\noutInitialDirection=initialDirection;\n#endif\n#ifdef CUSTOMEMITTER\noutDirection=direction;\n#else\nvec3 updatedDirection=direction+gravity*timeDelta;\n#ifdef LIMITVELOCITYGRADIENTS\nfloat limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;\nfloat currentVelocity=length(updatedDirection);\nif (currentVelocity>limitVelocity) {\nupdatedDirection=updatedDirection*limitVelocityDamping;\n}\n#endif\noutDirection=updatedDirection;\n#ifdef NOISE\nfloat fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;\nfloat fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;\nvec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;\noutDirection=outDirection+force*timeDelta;\noutNoiseCoordinates1=noiseCoordinates1;\noutNoiseCoordinates2=noiseCoordinates2;\n#endif\n#endif\n#ifdef ANGULARSPEEDGRADIENTS\nfloat angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;\noutAngle=angle+angularSpeed*timeDelta;\n#else\noutAngle=vec2(angle.x+angle.y*timeDelta,angle.y);\n#endif\n#ifdef ANIMATESHEET\nfloat offsetAge=outAge;\nfloat dist=cellInfos.y-cellInfos.x;\n#ifdef ANIMATESHEETRANDOMSTART\noutCellStartOffset=cellStartOffset;\noffsetAge+=cellStartOffset;\n#else\nfloat cellStartOffset=0.;\n#endif\nfloat ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);\noutCellIndex=float(int(cellInfos.x+ratio*dist));\n#endif\n}\n}`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var gpuUpdateParticlesVertexShader = { name, shader };\n"},"lineCount":null}},"error":null,"hash":"9e3872b6be198a58b2280b759c1efd35","cacheData":{"env":{}}}