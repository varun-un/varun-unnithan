{"id":"node_modules/@babylonjs/core/Shaders/ssao2.fragment.js","dependencies":[{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\Shaders\\ssao2.fragment.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\package.json","includedInParent":true,"mtime":1619016251814},{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\.babelrc","includedInParent":true,"mtime":1618361427593},{"name":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\package.json","includedInParent":true,"mtime":499162500000},{"name":"../Materials/effect","loc":{"line":1,"column":23},"parent":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\Shaders\\ssao2.fragment.js","resolved":"C:\\Users\\varun\\Documents\\Visual Studio\\varun-unnithan\\node_modules\\@babylonjs\\core\\Materials\\effect.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ssao2PixelShader = void 0;\n\nvar _effect = require(\"../Materials/effect\");\n\nvar name = 'ssao2PixelShader';\nvar shader = \"\\nprecision highp float;\\nuniform sampler2D textureSampler;\\nuniform float near;\\nuniform float far;\\nuniform float radius;\\nfloat scales[16]=float[16](\\n0.1,\\n0.11406250000000001,\\n0.131640625,\\n0.15625,\\n0.187890625,\\n0.2265625,\\n0.272265625,\\n0.325,\\n0.384765625,\\n0.4515625,\\n0.525390625,\\n0.60625,\\n0.694140625,\\n0.7890625,\\n0.891015625,\\n1.0\\n);\\nvarying vec2 vUV;\\nfloat perspectiveDepthToViewZ( const in float invClipZ,const in float near,const in float far ) {\\nreturn ( near*far )/( ( far-near )*invClipZ-far );\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ,const in float near,const in float far ) {\\nreturn ( near*far/viewZ+far)/( far-near );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ,const in float near,const in float far ) {\\nreturn ( viewZ+near )/( near-far );\\n}\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\n#ifndef GEOMETRYBUFFER\\nuniform sampler2D depthNormalSampler;\\n#else\\nuniform sampler2D depthSampler;\\nuniform sampler2D normalSampler;\\n#endif\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float base;\\nuniform float xViewport;\\nuniform float yViewport;\\nuniform float maxZ;\\nuniform float minZAspect;\\nuniform vec2 texelSize;\\nuniform mat4 projection;\\nvoid main()\\n{\\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\\n#ifndef GEOMETRYBUFFER\\nfloat depth=texture2D(depthNormalSampler,vUV).r;\\n#else\\nfloat depth=texture2D(depthSampler,vUV).r;\\n#endif\\nfloat depthSign=depth/abs(depth);\\ndepth=depth*depthSign;\\n#ifndef GEOMETRYBUFFER\\nvec3 normal=texture2D(depthNormalSampler,vUV).gba;\\n#else\\nvec3 normal=texture2D(normalSampler,vUV).rgb;\\n#endif\\nfloat occlusion=0.0;\\nfloat correctedRadius=min(radius,minZAspect*depth/near);\\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\\nvec3 origin=vViewRay*depth;\\nvec3 rvec=random*2.0-1.0;\\nrvec.z=0.0;\\n\\nfloat dotProduct=dot(rvec,normal);\\nrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\\nvec3 bitangent=cross(normal,tangent);\\nmat3 tbn=mat3(tangent,bitangent,normal);\\nfloat difference;\\nfor (int i=0; i<SAMPLES; ++i) {\\n\\nvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\\nsamplePosition=samplePosition*correctedRadius+origin;\\n\\nvec4 offset=vec4(samplePosition,1.0);\\noffset=projection*offset;\\noffset.xyz/=offset.w;\\noffset.xy=offset.xy*0.5+0.5;\\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\\ncontinue;\\n}\\n\\n#ifndef GEOMETRYBUFFER\\nfloat sampleDepth=abs(texture2D(depthNormalSampler,offset.xy).r);\\n#else\\nfloat sampleDepth=abs(texture2D(depthSampler,offset.xy).r);\\n#endif\\n\\ndifference=depthSign*samplePosition.z-sampleDepth;\\nfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\\nocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\\n}\\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor=vec4(vec3(result),1.0);\\n}\\n#endif\\n#ifdef BILATERAL_BLUR\\nuniform sampler2D depthNormalSampler;\\nuniform float outSize;\\nuniform float samplerOffsets[SAMPLES];\\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.3846153846)*direction;\\nvec2 off2=vec2(3.2307692308)*direction;\\ncolor+=texture2D(image,uv)*0.2270270270;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\\nreturn color;\\n}\\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\ncolor+=texture2D(image,uv)*0.1964825501511404;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\\nreturn color;\\n}\\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\nfloat compareDepth=abs(texture2D(depthNormalSampler,uv).r);\\nfloat sampleDepth;\\nfloat weight;\\nfloat weightSum=30.0;\\ncolor+=texture2D(image,uv)*30.0;\\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\\nreturn color/weightSum;\\n}\\nvoid main()\\n{\\n#if EXPENSIVE\\nfloat compareDepth=abs(texture2D(depthNormalSampler,vUV).r);\\nfloat texelsize=1.0/outSize;\\nfloat result=0.0;\\nfloat weightSum=0.0;\\nfor (int i=0; i<SAMPLES; ++i)\\n{\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\\n#endif\\nvec2 samplePos=vUV+sampleOffset;\\nfloat sampleDepth=abs(texture2D(depthNormalSampler,samplePos).r);\\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\\nresult+=texture2D(textureSampler,samplePos).r*weight;\\nweightSum+=weight;\\n}\\nresult/=weightSum;\\ngl_FragColor.rgb=vec3(result);\\ngl_FragColor.a=1.0;\\n#else\\nvec4 color;\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#endif\\ngl_FragColor.rgb=vec3(color.r);\\ngl_FragColor.a=1.0;\\n#endif\\n}\\n#endif\\n\";\n_effect.Effect.ShadersStore[name] = shader;\n/** @hidden */\n\nvar ssao2PixelShader = {\n  name: name,\n  shader: shader\n};\nexports.ssao2PixelShader = ssao2PixelShader;"},"sourceMaps":{"js":{"mappings":[{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":10,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":3,"column":4},"generated":{"line":10,"column":4}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":3,"column":8},"generated":{"line":10,"column":8}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":3,"column":11},"generated":{"line":10,"column":11}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":10,"column":29}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":11,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":4,"column":4},"generated":{"line":11,"column":4}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":4,"column":10},"generated":{"line":11,"column":10}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":11,"column":13}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":4,"column":0},"generated":{"line":11,"column":7254}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":0},"generated":{"line":12,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":7},"generated":{"line":12,"column":15}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":0},"generated":{"line":12,"column":27}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":20},"generated":{"line":12,"column":28}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":0},"generated":{"line":12,"column":32}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":28},"generated":{"line":12,"column":36}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":220,"column":0},"generated":{"line":12,"column":42}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":221,"column":0},"generated":{"line":13,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":7},"generated":{"line":15,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":11},"generated":{"line":15,"column":4}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":27},"generated":{"line":15,"column":20}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":30},"generated":{"line":15,"column":23}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":32},"generated":{"line":16,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":32},"generated":{"line":16,"column":2}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":36},"generated":{"line":16,"column":6}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":36},"generated":{"line":16,"column":8}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":30},"generated":{"line":16,"column":12}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":38},"generated":{"line":17,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":38},"generated":{"line":17,"column":2}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":44},"generated":{"line":17,"column":8}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":44},"generated":{"line":17,"column":10}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":30},"generated":{"line":18,"column":0}},{"source":"../../../sourceES6/core/Shaders/ssao2.fragment.ts","name":null,"original":{"line":222,"column":7},"generated":{"line":18,"column":1}}],"sources":{"../../../sourceES6/core/Shaders/ssao2.fragment.ts":"import { Effect } from \"../Materials/effect\";\n\nlet name = 'ssao2PixelShader';\nlet shader = `\nprecision highp float;\nuniform sampler2D textureSampler;\nuniform float near;\nuniform float far;\nuniform float radius;\nfloat scales[16]=float[16](\n0.1,\n0.11406250000000001,\n0.131640625,\n0.15625,\n0.187890625,\n0.2265625,\n0.272265625,\n0.325,\n0.384765625,\n0.4515625,\n0.525390625,\n0.60625,\n0.694140625,\n0.7890625,\n0.891015625,\n1.0\n);\nvarying vec2 vUV;\nfloat perspectiveDepthToViewZ( const in float invClipZ,const in float near,const in float far ) {\nreturn ( near*far )/( ( far-near )*invClipZ-far );\n}\nfloat viewZToPerspectiveDepth( const in float viewZ,const in float near,const in float far ) {\nreturn ( near*far/viewZ+far)/( far-near );\n}\nfloat viewZToOrthographicDepth( const in float viewZ,const in float near,const in float far ) {\nreturn ( viewZ+near )/( near-far );\n}\n#ifdef SSAO\nuniform sampler2D randomSampler;\n#ifndef GEOMETRYBUFFER\nuniform sampler2D depthNormalSampler;\n#else\nuniform sampler2D depthSampler;\nuniform sampler2D normalSampler;\n#endif\nuniform float randTextureTiles;\nuniform float samplesFactor;\nuniform vec3 sampleSphere[SAMPLES];\nuniform float totalStrength;\nuniform float base;\nuniform float xViewport;\nuniform float yViewport;\nuniform float maxZ;\nuniform float minZAspect;\nuniform vec2 texelSize;\nuniform mat4 projection;\nvoid main()\n{\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\n#ifndef GEOMETRYBUFFER\nfloat depth=texture2D(depthNormalSampler,vUV).r;\n#else\nfloat depth=texture2D(depthSampler,vUV).r;\n#endif\nfloat depthSign=depth/abs(depth);\ndepth=depth*depthSign;\n#ifndef GEOMETRYBUFFER\nvec3 normal=texture2D(depthNormalSampler,vUV).gba;\n#else\nvec3 normal=texture2D(normalSampler,vUV).rgb;\n#endif\nfloat occlusion=0.0;\nfloat correctedRadius=min(radius,minZAspect*depth/near);\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);\nvec3 origin=vViewRay*depth;\nvec3 rvec=random*2.0-1.0;\nrvec.z=0.0;\n\nfloat dotProduct=dot(rvec,normal);\nrvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\nvec3 bitangent=cross(normal,tangent);\nmat3 tbn=mat3(tangent,bitangent,normal);\nfloat difference;\nfor (int i=0; i<SAMPLES; ++i) {\n\nvec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];\nsamplePosition=samplePosition*correctedRadius+origin;\n\nvec4 offset=vec4(samplePosition,1.0);\noffset=projection*offset;\noffset.xyz/=offset.w;\noffset.xy=offset.xy*0.5+0.5;\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\ncontinue;\n}\n\n#ifndef GEOMETRYBUFFER\nfloat sampleDepth=abs(texture2D(depthNormalSampler,offset.xy).r);\n#else\nfloat sampleDepth=abs(texture2D(depthSampler,offset.xy).r);\n#endif\n\ndifference=depthSign*samplePosition.z-sampleDepth;\nfloat rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);\nocclusion+=(difference>=0.0 ? 1.0 : 0.0)*rangeCheck;\n}\nocclusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\nfloat result=clamp(ao+base,0.0,1.0);\ngl_FragColor=vec4(vec3(result),1.0);\n}\n#endif\n#ifdef BILATERAL_BLUR\nuniform sampler2D depthNormalSampler;\nuniform float outSize;\nuniform float samplerOffsets[SAMPLES];\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.3846153846)*direction;\nvec2 off2=vec2(3.2307692308)*direction;\ncolor+=texture2D(image,uv)*0.2270270270;\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\nreturn color;\n}\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.411764705882353)*direction;\nvec2 off2=vec2(3.2941176470588234)*direction;\nvec2 off3=vec2(5.176470588235294)*direction;\ncolor+=texture2D(image,uv)*0.1964825501511404;\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\nreturn color;\n}\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\nvec4 color=vec4(0.0);\nvec2 off1=vec2(1.411764705882353)*direction;\nvec2 off2=vec2(3.2941176470588234)*direction;\nvec2 off3=vec2(5.176470588235294)*direction;\nfloat compareDepth=abs(texture2D(depthNormalSampler,uv).r);\nfloat sampleDepth;\nfloat weight;\nfloat weightSum=30.0;\ncolor+=texture2D(image,uv)*30.0;\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off1/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off1/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off2/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off2/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv+(off3/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\nsampleDepth=abs(texture2D(depthNormalSampler,uv-(off3/resolution)).r);\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\nweightSum+=weight;\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\nreturn color/weightSum;\n}\nvoid main()\n{\n#if EXPENSIVE\nfloat compareDepth=abs(texture2D(depthNormalSampler,vUV).r);\nfloat texelsize=1.0/outSize;\nfloat result=0.0;\nfloat weightSum=0.0;\nfor (int i=0; i<SAMPLES; ++i)\n{\n#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\n#else\nvec2 direction=vec2(0.0,1.0);\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\n#endif\nvec2 samplePos=vUV+sampleOffset;\nfloat sampleDepth=abs(texture2D(depthNormalSampler,samplePos).r);\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\nresult+=texture2D(textureSampler,samplePos).r*weight;\nweightSum+=weight;\n}\nresult/=weightSum;\ngl_FragColor.rgb=vec3(result);\ngl_FragColor.a=1.0;\n#else\nvec4 color;\n#ifdef BILATERAL_BLUR_H\nvec2 direction=vec2(1.0,0.0);\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\n#else\nvec2 direction=vec2(0.0,1.0);\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\n#endif\ngl_FragColor.rgb=vec3(color.r);\ngl_FragColor.a=1.0;\n#endif\n}\n#endif\n`;\n\nEffect.ShadersStore[name] = shader;\n/** @hidden */\nexport var ssao2PixelShader = { name, shader };\n"},"lineCount":null}},"error":null,"hash":"80d68561942bd867cf6c9ac14dba671d","cacheData":{"env":{}}}